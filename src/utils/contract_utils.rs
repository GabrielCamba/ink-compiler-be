use crate::models::api_models::WizardMessage;
use crate::models::db_models::Contract;
use log::{error, info};
use sha2::{Digest, Sha256};
use std::env;
use std::fs::File;
use std::io::prelude::*;
use std::path::{Path, PathBuf};
use std::process::Command;

// Function called by the compiler to generate the contract wasm and metadata
// TODO: Move this function to compiler
pub fn compile_contract(
    cargo_path: &String,
    dir_path: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    // This is the command used to compile the contract
    let mut binding = Command::new(cargo_path);
    let compiler_cmd = binding
        .arg("contract")
        .arg("build")
        .arg("--release")
        .arg("--quiet")
        .current_dir(dir_path);

    // Check the status of the command execution
    let status = compiler_cmd.status()?;
    if !status.success() {
        error!(target: "compiler", "Compilation failed");
        return Err("Compilation failed".into());
    }
    info!(target: "compiler", "Compilation success");

    Ok(())
}

//  TODO: Check if this has to be moved to the compiler
// this function is used to read from the file system the wasm and metadata files generated by the compiler
pub fn get_contract_data(
    dir_path: &Path,
    code_id: &String,
) -> Result<Contract, Box<dyn std::error::Error>> {
    // Read compiled contract
    let mut wasm_file = File::open(dir_path.join("target/ink/compiled_contract.wasm"))?;
    let mut wasm = Vec::new();
    wasm_file.read_to_end(&mut wasm)?;

    // Read contract metadata
    let mut metadata_file = File::open(dir_path.join("target/ink/compiled_contract.json"))?;
    let mut metadata = String::new();
    metadata_file.read_to_string(&mut metadata)?;

    let contract = Contract {
        id: None,
        code_id: code_id.to_owned(),
        metadata,
        wasm,
    };
    info!(target: "compiler", "get_contract_data success");

    Ok(contract)
}

// TODO rename functions in favor of create_contract_files
// This function is used to create the contract files in the filesystem
pub fn create_files(wizard_message: &WizardMessage) -> Result<PathBuf, Box<dyn std::error::Error>> {
    let current_dir = env::current_dir().unwrap();
    let dir_path = current_dir.join("./compilation_target");

    let res_file = create_lib_rs_file(&wizard_message.code, &dir_path);
    // check the result
    if res_file.is_err() {
        error!(target: "compiler", "Error creating lib.rs file: {:?}", res_file);
        delete_files(&dir_path);
        return Err("Error creating lib.rs file".into());
    }
    info!(target: "compiler", "lib.rs successfully created");

    Ok(dir_path)
}

// TODO rename function to delete_compilation_files
// This function is used to delete the compiled contract files in the filesystem
pub fn delete_files(dir_path: &Path) {
    let res = std::fs::remove_dir_all(dir_path.join("target"));
    if res.is_err() {
        error!(target: "compiler", "Error deleting files: {:?}", res);
    }

    let res = std::fs::remove_dir_all(dir_path.join("__openbrush_metadata_folder"));
    if res.is_err() {
        error!(target: "compiler", "Error deleting files: {:?}", res);
    }
}

// This function creates the lib.rs file in the compiling directory
fn create_lib_rs_file(code: &String, dir_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let path = dir_path.join("lib.rs");
    let mut lib_rs_file = File::create(path)?;
    lib_rs_file.write_all(code.as_bytes())?;

    Ok(())
}

// This function creates the hash of the contract file
pub fn hash_code(code: &String) -> String {
    let mut hasher = Sha256::new();
    hasher.update(code);
    let code_id = hasher.finalize();
    format!("{:x}", code_id)
}

#[cfg(test)]
#[path = "../tests/utils/contract_utils_tests.rs"]
mod contract_utils_tests;
